/* tslint:disable */
/* eslint-disable */
/**
 * FPay Provider API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.4.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BoletoDefinition
 */
export interface BoletoDefinition {
    /**
     * 
     * @type {string}
     * @memberof BoletoDefinition
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BoletoDefinition
     */
    'resource'?: BoletoDefinitionResourceEnum;
    /**
     * 
     * @type {string}
     * @memberof BoletoDefinition
     */
    'customer'?: string;
    /**
     * 
     * @type {string}
     * @memberof BoletoDefinition
     */
    'status'?: BoletoDefinitionStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BoletoDefinition
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BoletoDefinition
     */
    'expiration_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof BoletoDefinition
     */
    'payment_limit_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof BoletoDefinition
     */
    'paid_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof BoletoDefinition
     */
    'bank_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof BoletoDefinition
     */
    'recipient'?: string;
    /**
     * 
     * @type {string}
     * @memberof BoletoDefinition
     */
    'uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof BoletoDefinition
     */
    'barcode'?: string;
    /**
     * 
     * @type {string}
     * @memberof BoletoDefinition
     */
    'address'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BoletoDefinition
     */
    'accepted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BoletoDefinition
     */
    'printed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BoletoDefinition
     */
    'downloaded'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof BoletoDefinition
     */
    'metadata'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof BoletoDefinition
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof BoletoDefinition
     */
    'updated_at'?: string;
}

export const BoletoDefinitionResourceEnum = {
    Boleto: 'boleto'
} as const;

export type BoletoDefinitionResourceEnum = typeof BoletoDefinitionResourceEnum[keyof typeof BoletoDefinitionResourceEnum];
export const BoletoDefinitionStatusEnum = {
    Paid: 'paid',
    NotPaid: 'not_paid'
} as const;

export type BoletoDefinitionStatusEnum = typeof BoletoDefinitionStatusEnum[keyof typeof BoletoDefinitionStatusEnum];

/**
 * 
 * @export
 * @interface BuyerDefinition
 */
export interface BuyerDefinition {
    /**
     * 
     * @type {string}
     * @memberof BuyerDefinition
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuyerDefinition
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuyerDefinition
     */
    'document_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuyerDefinition
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BuyerDefinition
     */
    'email_secondary'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BuyerDefinition
     */
    'phone_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BuyerDefinition
     */
    'birthdate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BuyerDefinition
     */
    'obs'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BuyerDefinition
     */
    'street'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BuyerDefinition
     */
    'house_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BuyerDefinition
     */
    'postal_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BuyerDefinition
     */
    'neighborhood'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BuyerDefinition
     */
    'city'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BuyerDefinition
     */
    'state_initials'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BuyerDefinition
     */
    'state'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BuyerDefinition
     */
    'country_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BuyerDefinition
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuyerDefinition
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface CardDefinition
 */
export interface CardDefinition {
    /**
     * 
     * @type {string}
     * @memberof CardDefinition
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardDefinition
     */
    'resource'?: CardDefinitionResourceEnum;
    /**
     * 
     * @type {string}
     * @memberof CardDefinition
     */
    'customer'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CardDefinition
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CardDefinition
     */
    'first4digits'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardDefinition
     */
    'last4digits'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardDefinition
     */
    'card_brand'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardDefinition
     */
    'expiration_month'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardDefinition
     */
    'expiration_year'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardDefinition
     */
    'holder_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardDefinition
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardDefinition
     */
    'updated_at'?: string;
}

export const CardDefinitionResourceEnum = {
    Card: 'card'
} as const;

export type CardDefinitionResourceEnum = typeof CardDefinitionResourceEnum[keyof typeof CardDefinitionResourceEnum];

/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'customer'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'holder_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'expiration_month'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'expiration_year'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'card_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'security_code'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface InvoiceDefinition
 */
export interface InvoiceDefinition {
    /**
     * 
     * @type {string}
     * @memberof InvoiceDefinition
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDefinition
     */
    'resource'?: InvoiceDefinitionResourceEnum;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDefinition
     */
    'subscription'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDefinition
     */
    'customer'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDefinition
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDefinition
     */
    'payment_method'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDefinition
     */
    'due_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDefinition
     */
    'expiration_date'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceDefinition
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDefinition
     */
    'currency'?: InvoiceDefinitionCurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDefinition
     */
    'paid_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDefinition
     */
    'voided_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceDefinition
     */
    'retries'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceDefinition
     */
    'max_retries'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDefinition
     */
    'status'?: InvoiceDefinitionStatusEnum;
    /**
     * 
     * @type {object}
     * @memberof InvoiceDefinition
     */
    'metadata'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDefinition
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDefinition
     */
    'updated_at'?: string;
}

export const InvoiceDefinitionResourceEnum = {
    Invoice: 'invoice'
} as const;

export type InvoiceDefinitionResourceEnum = typeof InvoiceDefinitionResourceEnum[keyof typeof InvoiceDefinitionResourceEnum];
export const InvoiceDefinitionCurrencyEnum = {
    Brl: 'BRL'
} as const;

export type InvoiceDefinitionCurrencyEnum = typeof InvoiceDefinitionCurrencyEnum[keyof typeof InvoiceDefinitionCurrencyEnum];
export const InvoiceDefinitionStatusEnum = {
    Paid: 'paid',
    Pending: 'pending',
    Canceled: 'canceled',
    Failed: 'failed'
} as const;

export type InvoiceDefinitionStatusEnum = typeof InvoiceDefinitionStatusEnum[keyof typeof InvoiceDefinitionStatusEnum];

/**
 * 
 * @export
 * @interface ListDefinition
 */
export interface ListDefinition {
    /**
     * 
     * @type {string}
     * @memberof ListDefinition
     */
    'resource'?: ListDefinitionResourceEnum;
    /**
     * 
     * @type {Array<object>}
     * @memberof ListDefinition
     */
    'items'?: Array<object>;
    /**
     * 
     * @type {number}
     * @memberof ListDefinition
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListDefinition
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListDefinition
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListDefinition
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListDefinition
     */
    'total_pages'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ListDefinition
     */
    'has_more'?: boolean;
}

export const ListDefinitionResourceEnum = {
    List: 'list'
} as const;

export type ListDefinitionResourceEnum = typeof ListDefinitionResourceEnum[keyof typeof ListDefinitionResourceEnum];

/**
 * 
 * @export
 * @interface PlanDefinition
 */
export interface PlanDefinition {
    /**
     * 
     * @type {string}
     * @memberof PlanDefinition
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanDefinition
     */
    'resource'?: PlanDefinitionResourceEnum;
    /**
     * 
     * @type {string}
     * @memberof PlanDefinition
     */
    'marketplace'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanDefinition
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanDefinition
     */
    'frequency'?: PlanDefinitionFrequencyEnum;
    /**
     * 
     * @type {number}
     * @memberof PlanDefinition
     */
    'interval'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlanDefinition
     */
    'payment_methods'?: string;
    /**
     * 
     * @type {number}
     * @memberof PlanDefinition
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlanDefinition
     */
    'setup_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlanDefinition
     */
    'currency'?: PlanDefinitionCurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof PlanDefinition
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PlanDefinition
     */
    'duration'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlanDefinition
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanDefinition
     */
    'updated_at'?: string;
}

export const PlanDefinitionResourceEnum = {
    Plan: 'plan'
} as const;

export type PlanDefinitionResourceEnum = typeof PlanDefinitionResourceEnum[keyof typeof PlanDefinitionResourceEnum];
export const PlanDefinitionFrequencyEnum = {
    Daily: 'daily',
    Monthly: 'monthly',
    Weekly: 'weekly',
    Annually: 'annually'
} as const;

export type PlanDefinitionFrequencyEnum = typeof PlanDefinitionFrequencyEnum[keyof typeof PlanDefinitionFrequencyEnum];
export const PlanDefinitionCurrencyEnum = {
    Brl: 'BRL'
} as const;

export type PlanDefinitionCurrencyEnum = typeof PlanDefinitionCurrencyEnum[keyof typeof PlanDefinitionCurrencyEnum];

/**
 * 
 * @export
 * @interface SubscriptionDefinition
 */
export interface SubscriptionDefinition {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDefinition
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDefinition
     */
    'resource'?: SubscriptionDefinitionResourceEnum;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDefinition
     */
    'plan'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDefinition
     */
    'customer'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDefinition
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDefinition
     */
    'payment_method'?: SubscriptionDefinitionPaymentMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDefinition
     */
    'due_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDefinition
     */
    'due_since_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDefinition
     */
    'expiration_date'?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionDefinition
     */
    'amount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDefinition
     */
    'currency'?: SubscriptionDefinitionCurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDefinition
     */
    'status'?: SubscriptionDefinitionStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDefinition
     */
    'suspended_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDefinition
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDefinition
     */
    'updated_at'?: string;
}

export const SubscriptionDefinitionResourceEnum = {
    Subscription: 'subscription'
} as const;

export type SubscriptionDefinitionResourceEnum = typeof SubscriptionDefinitionResourceEnum[keyof typeof SubscriptionDefinitionResourceEnum];
export const SubscriptionDefinitionPaymentMethodEnum = {
    Credit: 'credit'
} as const;

export type SubscriptionDefinitionPaymentMethodEnum = typeof SubscriptionDefinitionPaymentMethodEnum[keyof typeof SubscriptionDefinitionPaymentMethodEnum];
export const SubscriptionDefinitionCurrencyEnum = {
    Brl: 'BRL'
} as const;

export type SubscriptionDefinitionCurrencyEnum = typeof SubscriptionDefinitionCurrencyEnum[keyof typeof SubscriptionDefinitionCurrencyEnum];
export const SubscriptionDefinitionStatusEnum = {
    Active: 'active',
    Canceled: 'canceled',
    Expired: 'expired',
    Suspended: 'suspended'
} as const;

export type SubscriptionDefinitionStatusEnum = typeof SubscriptionDefinitionStatusEnum[keyof typeof SubscriptionDefinitionStatusEnum];

/**
 * 
 * @export
 * @interface TokenDefinition
 */
export interface TokenDefinition {
    /**
     * 
     * @type {string}
     * @memberof TokenDefinition
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenDefinition
     */
    'resource'?: TokenDefinitionResourceEnum;
    /**
     * 
     * @type {boolean}
     * @memberof TokenDefinition
     */
    'used'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TokenDefinition
     */
    'type'?: TokenDefinitionTypeEnum;
    /**
     * 
     * @type {CardDefinition}
     * @memberof TokenDefinition
     */
    'card'?: CardDefinition;
    /**
     * 
     * @type {string}
     * @memberof TokenDefinition
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenDefinition
     */
    'updated_at'?: string;
}

export const TokenDefinitionResourceEnum = {
    Token: 'token'
} as const;

export type TokenDefinitionResourceEnum = typeof TokenDefinitionResourceEnum[keyof typeof TokenDefinitionResourceEnum];
export const TokenDefinitionTypeEnum = {
    Card: 'card'
} as const;

export type TokenDefinitionTypeEnum = typeof TokenDefinitionTypeEnum[keyof typeof TokenDefinitionTypeEnum];

/**
 * 
 * @export
 * @interface TransactionDefinition
 */
export interface TransactionDefinition {
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinition
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinition
     */
    'resource'?: TransactionDefinitionResourceEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinition
     */
    'on_behalf_of'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinition
     */
    'customer'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinition
     */
    'status'?: TransactionDefinitionStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof TransactionDefinition
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionDefinition
     */
    'originalAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinition
     */
    'currency'?: TransactionDefinitionCurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinition
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinition
     */
    'statement_descriptor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinition
     */
    'payment_type'?: TransactionDefinitionPaymentTypeEnum;
    /**
     * 
     * @type {CardDefinition | BoletoDefinition}
     * @memberof TransactionDefinition
     */
    'payment_method'?: CardDefinition | BoletoDefinition;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinition
     */
    'transaction_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinition
     */
    'gateway_authorizer'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinition
     */
    'sales_receipt'?: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionDefinition
     */
    'installment_plan'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionDefinition
     */
    'refunded'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionDefinition
     */
    'voided'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionDefinition
     */
    'captured'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinition
     */
    'fees'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinition
     */
    'expected_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinition
     */
    'voided_at'?: string;
    /**
     * 
     * @type {Array<TransactionDefinitionHistory>}
     * @memberof TransactionDefinition
     */
    'history'?: Array<TransactionDefinitionHistory>;
    /**
     * 
     * @type {object}
     * @memberof TransactionDefinition
     */
    'metadata'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinition
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinition
     */
    'updated_at'?: string;
}

export const TransactionDefinitionResourceEnum = {
    Transaction: 'transaction'
} as const;

export type TransactionDefinitionResourceEnum = typeof TransactionDefinitionResourceEnum[keyof typeof TransactionDefinitionResourceEnum];
export const TransactionDefinitionStatusEnum = {
    New: 'new',
    Pending: 'pending',
    PreAuthorized: 'pre_authorized',
    Succeeded: 'succeeded',
    Canceled: 'canceled',
    Failed: 'failed',
    Reversed: 'reversed',
    Refunded: 'refunded',
    Dispute: 'dispute',
    ChargeBack: 'charge_back'
} as const;

export type TransactionDefinitionStatusEnum = typeof TransactionDefinitionStatusEnum[keyof typeof TransactionDefinitionStatusEnum];
export const TransactionDefinitionCurrencyEnum = {
    Brl: 'BRL'
} as const;

export type TransactionDefinitionCurrencyEnum = typeof TransactionDefinitionCurrencyEnum[keyof typeof TransactionDefinitionCurrencyEnum];
export const TransactionDefinitionPaymentTypeEnum = {
    Credit: 'credit',
    Boleto: 'boleto'
} as const;

export type TransactionDefinitionPaymentTypeEnum = typeof TransactionDefinitionPaymentTypeEnum[keyof typeof TransactionDefinitionPaymentTypeEnum];

/**
 * 
 * @export
 * @interface TransactionDefinitionHistory
 */
export interface TransactionDefinitionHistory {
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinitionHistory
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinitionHistory
     */
    'amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinitionHistory
     */
    'status'?: TransactionDefinitionHistoryStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinitionHistory
     */
    'authorizer'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinitionHistory
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinitionHistory
     */
    'transaction'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinitionHistory
     */
    'authorizer_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinitionHistory
     */
    'response_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinitionHistory
     */
    'operation_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinitionHistory
     */
    'response_message'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinitionHistory
     */
    'authorization_nsu'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinitionHistory
     */
    'authorization_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDefinitionHistory
     */
    'gatewayResponseTime'?: string;
}

export const TransactionDefinitionHistoryStatusEnum = {
    New: 'new',
    Pending: 'pending',
    PreAuthorized: 'pre_authorized',
    Succeeded: 'succeeded',
    Canceled: 'canceled',
    Failed: 'failed',
    Reversed: 'reversed',
    Refunded: 'refunded',
    Dispute: 'dispute',
    ChargeBack: 'charge_back'
} as const;

export type TransactionDefinitionHistoryStatusEnum = typeof TransactionDefinitionHistoryStatusEnum[keyof typeof TransactionDefinitionHistoryStatusEnum];

/**
 * 
 * @export
 * @interface WebhookDefinition
 */
export interface WebhookDefinition {
    /**
     * 
     * @type {string}
     * @memberof WebhookDefinition
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookDefinition
     */
    'resource'?: WebhookDefinitionResourceEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookDefinition
     */
    'endpoint'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookDefinition
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookDefinition
     */
    'event'?: WebhookDefinitionEventEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookDefinition
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookDefinition
     */
    'updated_at'?: string;
}

export const WebhookDefinitionResourceEnum = {
    Event: 'event'
} as const;

export type WebhookDefinitionResourceEnum = typeof WebhookDefinitionResourceEnum[keyof typeof WebhookDefinitionResourceEnum];
export const WebhookDefinitionEventEnum = {
    All: 'all',
    BankAccountAssociated: 'bank_account.associated',
    BankAccountDeleted: 'bank_account.deleted',
    BuyerTransactionCanceled: 'buyer.transaction.canceled',
    BuyerTransactionChargeBack: 'buyer.transaction.charge_back',
    BuyerTransactionDisputed: 'buyer.transaction.disputed',
    BuyerTransactionFailed: 'buyer.transaction.failed',
    BuyerTransactionPreAuthorized: 'buyer.transaction.pre_authorized',
    BuyerTransactionReversed: 'buyer.transaction.reversed',
    BuyerTransactionSucceeded: 'buyer.transaction.succeeded',
    BuyerTransactionUpdated: 'buyer.transaction.updated',
    BuyerCardAssociated: 'buyer.card.associated',
    DocumentCreated: 'document.created',
    DocumentUpdated: 'document.updated',
    InvoiceCreated: 'invoice.created',
    InvoiceCanceled: 'invoice.canceled',
    InvoiceOverdue: 'invoice.overdue',
    InvoicePaid: 'invoice.paid',
    InvoiceRefunded: 'invoice.refunded',
    PlanCreated: 'plan.created',
    PlanDeleted: 'plan.deleted',
    PlanUpdated: 'plan.updated',
    ReceivableCanceled: 'receivable.canceled',
    ReceivableCreated: 'receivable.created',
    ReceivableDeleted: 'receivable.deleted',
    ReceivablePaid: 'receivable.paid',
    ReceivableRefunded: 'receivable.refunded',
    ReceivableScheduled: 'receivable.scheduled',
    SellerActived: 'seller.actived',
    SellerCreated: 'seller.created',
    SellerDeleted: 'seller.deleted',
    SellerDenied: 'seller.denied',
    SellerEnabled: 'seller.enabled',
    SellerUpdated: 'seller.updated',
    SubscriptionActive: 'subscription.active',
    SubscriptionCreated: 'subscription.created',
    SubscriptionDeleted: 'subscription.deleted',
    SubscriptionExpired: 'subscription.expired',
    SubscriptionSuspended: 'subscription.suspended',
    SubscriptionUpdated: 'subscription.updated',
    SubscriptionPaid: 'subscription.paid',
    TransactionCanceled: 'transaction.canceled',
    TransactionCaptureFailed: 'transaction.capture.failed',
    TransactionCaptureSucceeded: 'transaction.capture.succeeded',
    TransactionChargeBack: 'transaction.charge_back',
    TransactionCommissionSucceeded: 'transaction.commission.succeeded',
    TransactionCreated: 'transaction.created',
    TransactionDisputeSucceeded: 'transaction.dispute.succeeded',
    TransactionDisputed: 'transaction.disputed',
    TransactionFailed: 'transaction.failed',
    TransactionPreAuthorizationSucceeded: 'transaction.pre_authorization.succeeded',
    TransactionPreAuthorized: 'transaction.pre_authorized',
    TransactionReversed: 'transaction.reversed',
    TransactionSucceeded: 'transaction.succeeded',
    TransactionUpdated: 'transaction.updated',
    TransactionVoidFailed: 'transaction.void.failed',
    TransactionVoidSucceeded: 'transaction.void.succeeded',
    TransferCanceled: 'transfer.canceled',
    TransferConfirmed: 'transfer.confirmed',
    TransferCreated: 'transfer.created',
    TransferFailed: 'transfer.failed',
    TransferSucceeded: 'transfer.succeeded'
} as const;

export type WebhookDefinitionEventEnum = typeof WebhookDefinitionEventEnum[keyof typeof WebhookDefinitionEventEnum];


/**
 * BuyersApi - axios parameter creator
 * @export
 */
export const BuyersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} marketaplaceId Identificador do marketplace
         * @param {BuyerDefinition} [buyerDefinition] Informações para criar um comprador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuyer: async (marketaplaceId: string, buyerDefinition?: BuyerDefinition, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketaplaceId' is not null or undefined
            assertParamExists('createBuyer', 'marketaplaceId', marketaplaceId)
            const localVarPath = `/marketplaces/{marketaplace_id}/buyers`
                .replace(`{${"marketaplace_id"}}`, encodeURIComponent(String(marketaplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(buyerDefinition, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketaplaceId Identificador do marketplace
         * @param {string} buyerId Identificador do comprador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuyer: async (marketaplaceId: string, buyerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketaplaceId' is not null or undefined
            assertParamExists('deleteBuyer', 'marketaplaceId', marketaplaceId)
            // verify required parameter 'buyerId' is not null or undefined
            assertParamExists('deleteBuyer', 'buyerId', buyerId)
            const localVarPath = `/marketplaces/{marketaplace_id}/buyers/{buyer_id}`
                .replace(`{${"marketaplace_id"}}`, encodeURIComponent(String(marketaplaceId)))
                .replace(`{${"buyer_id"}}`, encodeURIComponent(String(buyerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketaplaceId Identificador do marketplace
         * @param {string} buyerId Identificador do comprador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuyer: async (marketaplaceId: string, buyerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketaplaceId' is not null or undefined
            assertParamExists('getBuyer', 'marketaplaceId', marketaplaceId)
            // verify required parameter 'buyerId' is not null or undefined
            assertParamExists('getBuyer', 'buyerId', buyerId)
            const localVarPath = `/marketplaces/{marketaplace_id}/buyers/{buyer_id}`
                .replace(`{${"marketaplace_id"}}`, encodeURIComponent(String(marketaplaceId)))
                .replace(`{${"buyer_id"}}`, encodeURIComponent(String(buyerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketaplaceId Identificador do marketplace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuyers: async (marketaplaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketaplaceId' is not null or undefined
            assertParamExists('getBuyers', 'marketaplaceId', marketaplaceId)
            const localVarPath = `/marketplaces/{marketaplace_id}/buyers`
                .replace(`{${"marketaplace_id"}}`, encodeURIComponent(String(marketaplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketaplaceId Identificador do marketplace
         * @param {string} buyerId Identificador do comprador
         * @param {BuyerDefinition} [buyerDefinition] Informações para atualizar um comprador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuyer: async (marketaplaceId: string, buyerId: string, buyerDefinition?: BuyerDefinition, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketaplaceId' is not null or undefined
            assertParamExists('updateBuyer', 'marketaplaceId', marketaplaceId)
            // verify required parameter 'buyerId' is not null or undefined
            assertParamExists('updateBuyer', 'buyerId', buyerId)
            const localVarPath = `/marketplaces/{marketaplace_id}/buyers/{buyer_id}`
                .replace(`{${"marketaplace_id"}}`, encodeURIComponent(String(marketaplaceId)))
                .replace(`{${"buyer_id"}}`, encodeURIComponent(String(buyerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(buyerDefinition, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BuyersApi - functional programming interface
 * @export
 */
export const BuyersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BuyersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} marketaplaceId Identificador do marketplace
         * @param {BuyerDefinition} [buyerDefinition] Informações para criar um comprador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBuyer(marketaplaceId: string, buyerDefinition?: BuyerDefinition, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BuyerDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBuyer(marketaplaceId, buyerDefinition, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketaplaceId Identificador do marketplace
         * @param {string} buyerId Identificador do comprador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBuyer(marketaplaceId: string, buyerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBuyer(marketaplaceId, buyerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketaplaceId Identificador do marketplace
         * @param {string} buyerId Identificador do comprador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBuyer(marketaplaceId: string, buyerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BuyerDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBuyer(marketaplaceId, buyerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketaplaceId Identificador do marketplace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBuyers(marketaplaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDefinition & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBuyers(marketaplaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketaplaceId Identificador do marketplace
         * @param {string} buyerId Identificador do comprador
         * @param {BuyerDefinition} [buyerDefinition] Informações para atualizar um comprador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBuyer(marketaplaceId: string, buyerId: string, buyerDefinition?: BuyerDefinition, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BuyerDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBuyer(marketaplaceId, buyerId, buyerDefinition, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BuyersApi - factory interface
 * @export
 */
export const BuyersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BuyersApiFp(configuration)
    return {
        /**
         * 
         * @param {string} marketaplaceId Identificador do marketplace
         * @param {BuyerDefinition} [buyerDefinition] Informações para criar um comprador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuyer(marketaplaceId: string, buyerDefinition?: BuyerDefinition, options?: any): AxiosPromise<BuyerDefinition> {
            return localVarFp.createBuyer(marketaplaceId, buyerDefinition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketaplaceId Identificador do marketplace
         * @param {string} buyerId Identificador do comprador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuyer(marketaplaceId: string, buyerId: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.deleteBuyer(marketaplaceId, buyerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketaplaceId Identificador do marketplace
         * @param {string} buyerId Identificador do comprador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuyer(marketaplaceId: string, buyerId: string, options?: any): AxiosPromise<BuyerDefinition> {
            return localVarFp.getBuyer(marketaplaceId, buyerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketaplaceId Identificador do marketplace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuyers(marketaplaceId: string, options?: any): AxiosPromise<ListDefinition & object> {
            return localVarFp.getBuyers(marketaplaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketaplaceId Identificador do marketplace
         * @param {string} buyerId Identificador do comprador
         * @param {BuyerDefinition} [buyerDefinition] Informações para atualizar um comprador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuyer(marketaplaceId: string, buyerId: string, buyerDefinition?: BuyerDefinition, options?: any): AxiosPromise<BuyerDefinition> {
            return localVarFp.updateBuyer(marketaplaceId, buyerId, buyerDefinition, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BuyersApi - object-oriented interface
 * @export
 * @class BuyersApi
 * @extends {BaseAPI}
 */
export class BuyersApi extends BaseAPI {
    /**
     * 
     * @param {string} marketaplaceId Identificador do marketplace
     * @param {BuyerDefinition} [buyerDefinition] Informações para criar um comprador
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyersApi
     */
    public createBuyer(marketaplaceId: string, buyerDefinition?: BuyerDefinition, options?: AxiosRequestConfig) {
        return BuyersApiFp(this.configuration).createBuyer(marketaplaceId, buyerDefinition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketaplaceId Identificador do marketplace
     * @param {string} buyerId Identificador do comprador
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyersApi
     */
    public deleteBuyer(marketaplaceId: string, buyerId: string, options?: AxiosRequestConfig) {
        return BuyersApiFp(this.configuration).deleteBuyer(marketaplaceId, buyerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketaplaceId Identificador do marketplace
     * @param {string} buyerId Identificador do comprador
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyersApi
     */
    public getBuyer(marketaplaceId: string, buyerId: string, options?: AxiosRequestConfig) {
        return BuyersApiFp(this.configuration).getBuyer(marketaplaceId, buyerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketaplaceId Identificador do marketplace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyersApi
     */
    public getBuyers(marketaplaceId: string, options?: AxiosRequestConfig) {
        return BuyersApiFp(this.configuration).getBuyers(marketaplaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketaplaceId Identificador do marketplace
     * @param {string} buyerId Identificador do comprador
     * @param {BuyerDefinition} [buyerDefinition] Informações para atualizar um comprador
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyersApi
     */
    public updateBuyer(marketaplaceId: string, buyerId: string, buyerDefinition?: BuyerDefinition, options?: AxiosRequestConfig) {
        return BuyersApiFp(this.configuration).updateBuyer(marketaplaceId, buyerId, buyerDefinition, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BuyersCardApi - axios parameter creator
 * @export
 */
export const BuyersCardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} buyerId Identificador do comprador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCards: async (marketplaceId: string, buyerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('getCards', 'marketplaceId', marketplaceId)
            // verify required parameter 'buyerId' is not null or undefined
            assertParamExists('getCards', 'buyerId', buyerId)
            const localVarPath = `/marketplaces/{marketplace_id}/buyers/{buyer_id}/cards`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)))
                .replace(`{${"buyer_id"}}`, encodeURIComponent(String(buyerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} buyerId Identificador do comprador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerDefaultCard: async (marketplaceId: string, buyerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('getCustomerDefaultCard', 'marketplaceId', marketplaceId)
            // verify required parameter 'buyerId' is not null or undefined
            assertParamExists('getCustomerDefaultCard', 'buyerId', buyerId)
            const localVarPath = `/marketplaces/{marketplace_id}/buyers/{buyer_id}/cards/default`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)))
                .replace(`{${"buyer_id"}}`, encodeURIComponent(String(buyerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} buyerId Identificador do comprador
         * @param {string} cardId Identificador do cartão de crédito
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultCardForCustomer: async (marketplaceId: string, buyerId: string, cardId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('setDefaultCardForCustomer', 'marketplaceId', marketplaceId)
            // verify required parameter 'buyerId' is not null or undefined
            assertParamExists('setDefaultCardForCustomer', 'buyerId', buyerId)
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('setDefaultCardForCustomer', 'cardId', cardId)
            const localVarPath = `/marketplaces/{marketplace_id}/buyers/{buyer_id}/cards/{card_id}/default`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)))
                .replace(`{${"buyer_id"}}`, encodeURIComponent(String(buyerId)))
                .replace(`{${"card_id"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BuyersCardApi - functional programming interface
 * @export
 */
export const BuyersCardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BuyersCardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} buyerId Identificador do comprador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCards(marketplaceId: string, buyerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDefinition & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCards(marketplaceId, buyerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} buyerId Identificador do comprador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerDefaultCard(marketplaceId: string, buyerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerDefaultCard(marketplaceId, buyerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} buyerId Identificador do comprador
         * @param {string} cardId Identificador do cartão de crédito
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDefaultCardForCustomer(marketplaceId: string, buyerId: string, cardId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDefaultCardForCustomer(marketplaceId, buyerId, cardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BuyersCardApi - factory interface
 * @export
 */
export const BuyersCardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BuyersCardApiFp(configuration)
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} buyerId Identificador do comprador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCards(marketplaceId: string, buyerId: string, options?: any): AxiosPromise<ListDefinition & object> {
            return localVarFp.getCards(marketplaceId, buyerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} buyerId Identificador do comprador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerDefaultCard(marketplaceId: string, buyerId: string, options?: any): AxiosPromise<CardDefinition> {
            return localVarFp.getCustomerDefaultCard(marketplaceId, buyerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} buyerId Identificador do comprador
         * @param {string} cardId Identificador do cartão de crédito
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultCardForCustomer(marketplaceId: string, buyerId: string, cardId: string, options?: any): AxiosPromise<CardDefinition> {
            return localVarFp.setDefaultCardForCustomer(marketplaceId, buyerId, cardId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BuyersCardApi - object-oriented interface
 * @export
 * @class BuyersCardApi
 * @extends {BaseAPI}
 */
export class BuyersCardApi extends BaseAPI {
    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {string} buyerId Identificador do comprador
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyersCardApi
     */
    public getCards(marketplaceId: string, buyerId: string, options?: AxiosRequestConfig) {
        return BuyersCardApiFp(this.configuration).getCards(marketplaceId, buyerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {string} buyerId Identificador do comprador
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyersCardApi
     */
    public getCustomerDefaultCard(marketplaceId: string, buyerId: string, options?: AxiosRequestConfig) {
        return BuyersCardApiFp(this.configuration).getCustomerDefaultCard(marketplaceId, buyerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {string} buyerId Identificador do comprador
     * @param {string} cardId Identificador do cartão de crédito
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyersCardApi
     */
    public setDefaultCardForCustomer(marketplaceId: string, buyerId: string, cardId: string, options?: AxiosRequestConfig) {
        return BuyersCardApiFp(this.configuration).setDefaultCardForCustomer(marketplaceId, buyerId, cardId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BuyersInvoicesApi - axios parameter creator
 * @export
 */
export const BuyersInvoicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} buyerId Identificador do comprador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicesByBuyer: async (marketplaceId: string, buyerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('getInvoicesByBuyer', 'marketplaceId', marketplaceId)
            // verify required parameter 'buyerId' is not null or undefined
            assertParamExists('getInvoicesByBuyer', 'buyerId', buyerId)
            const localVarPath = `/marketplaces/{marketplace_id}/buyers/{buyer_id}/invoices`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)))
                .replace(`{${"buyer_id"}}`, encodeURIComponent(String(buyerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BuyersInvoicesApi - functional programming interface
 * @export
 */
export const BuyersInvoicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BuyersInvoicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} buyerId Identificador do comprador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoicesByBuyer(marketplaceId: string, buyerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDefinition & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoicesByBuyer(marketplaceId, buyerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BuyersInvoicesApi - factory interface
 * @export
 */
export const BuyersInvoicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BuyersInvoicesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} buyerId Identificador do comprador
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicesByBuyer(marketplaceId: string, buyerId: string, options?: any): AxiosPromise<ListDefinition & object> {
            return localVarFp.getInvoicesByBuyer(marketplaceId, buyerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BuyersInvoicesApi - object-oriented interface
 * @export
 * @class BuyersInvoicesApi
 * @extends {BaseAPI}
 */
export class BuyersInvoicesApi extends BaseAPI {
    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {string} buyerId Identificador do comprador
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyersInvoicesApi
     */
    public getInvoicesByBuyer(marketplaceId: string, buyerId: string, options?: AxiosRequestConfig) {
        return BuyersInvoicesApiFp(this.configuration).getInvoicesByBuyer(marketplaceId, buyerId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CardsApi - axios parameter creator
 * @export
 */
export const CardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        associateCardWithCustomer: async (marketplaceId: string, inlineObject?: InlineObject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('associateCardWithCustomer', 'marketplaceId', marketplaceId)
            const localVarPath = `/marketplaces/{marketplace_id}/cards`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} cardId Identificador do cartão de crédito
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCard: async (marketplaceId: string, cardId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('deleteCard', 'marketplaceId', marketplaceId)
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('deleteCard', 'cardId', cardId)
            const localVarPath = `/marketplaces/{marketplace_id}/cards/{card_id}`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)))
                .replace(`{${"card_id"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCardToken: async (marketplaceId: string, inlineObject1?: InlineObject1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('generateCardToken', 'marketplaceId', marketplaceId)
            const localVarPath = `/marketplaces/{marketplace_id}/cards/tokens`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} cardId Identificador do cartão de crédito
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCard: async (marketplaceId: string, cardId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('getCard', 'marketplaceId', marketplaceId)
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('getCard', 'cardId', cardId)
            const localVarPath = `/marketplaces/{marketplace_id}/cards/{card_id}`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)))
                .replace(`{${"card_id"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardsApi - functional programming interface
 * @export
 */
export const CardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CardsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async associateCardWithCustomer(marketplaceId: string, inlineObject?: InlineObject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.associateCardWithCustomer(marketplaceId, inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} cardId Identificador do cartão de crédito
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCard(marketplaceId: string, cardId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCard(marketplaceId, cardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateCardToken(marketplaceId: string, inlineObject1?: InlineObject1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateCardToken(marketplaceId, inlineObject1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} cardId Identificador do cartão de crédito
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCard(marketplaceId: string, cardId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCard(marketplaceId, cardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CardsApi - factory interface
 * @export
 */
export const CardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CardsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        associateCardWithCustomer(marketplaceId: string, inlineObject?: InlineObject, options?: any): AxiosPromise<CardDefinition> {
            return localVarFp.associateCardWithCustomer(marketplaceId, inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} cardId Identificador do cartão de crédito
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCard(marketplaceId: string, cardId: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.deleteCard(marketplaceId, cardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCardToken(marketplaceId: string, inlineObject1?: InlineObject1, options?: any): AxiosPromise<TokenDefinition> {
            return localVarFp.generateCardToken(marketplaceId, inlineObject1, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} cardId Identificador do cartão de crédito
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCard(marketplaceId: string, cardId: string, options?: any): AxiosPromise<CardDefinition> {
            return localVarFp.getCard(marketplaceId, cardId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CardsApi - object-oriented interface
 * @export
 * @class CardsApi
 * @extends {BaseAPI}
 */
export class CardsApi extends BaseAPI {
    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {InlineObject} [inlineObject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public associateCardWithCustomer(marketplaceId: string, inlineObject?: InlineObject, options?: AxiosRequestConfig) {
        return CardsApiFp(this.configuration).associateCardWithCustomer(marketplaceId, inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {string} cardId Identificador do cartão de crédito
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public deleteCard(marketplaceId: string, cardId: string, options?: AxiosRequestConfig) {
        return CardsApiFp(this.configuration).deleteCard(marketplaceId, cardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {InlineObject1} [inlineObject1] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public generateCardToken(marketplaceId: string, inlineObject1?: InlineObject1, options?: AxiosRequestConfig) {
        return CardsApiFp(this.configuration).generateCardToken(marketplaceId, inlineObject1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {string} cardId Identificador do cartão de crédito
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public getCard(marketplaceId: string, cardId: string, options?: AxiosRequestConfig) {
        return CardsApiFp(this.configuration).getCard(marketplaceId, cardId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvoicesApi - axios parameter creator
 * @export
 */
export const InvoicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} invoiceId Identificador da fatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveInvoice: async (marketplaceId: string, invoiceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('approveInvoice', 'marketplaceId', marketplaceId)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('approveInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/marketplaces/{marketplace_id}/invoices/{invoice_id}/approve`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)))
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} invoiceId Identificador da fatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelInvoice: async (marketplaceId: string, invoiceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('cancelInvoice', 'marketplaceId', marketplaceId)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('cancelInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/marketplaces/{marketplace_id}/invoices/{invoice_id}`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)))
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador marketplace
         * @param {InvoiceDefinition} [invoiceDefinition] Informações para criar uma fatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoice: async (marketplaceId: string, invoiceDefinition?: InvoiceDefinition, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('createInvoice', 'marketplaceId', marketplaceId)
            const localVarPath = `/marketplaces/{marketplace_id}/invoices`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceDefinition, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} invoiceId Identificador da fatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice: async (marketplaceId: string, invoiceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('getInvoice', 'marketplaceId', marketplaceId)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('getInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/marketplaces/{marketplace_id}/invoices/{invoice_id}`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)))
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoices: async (marketplaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('getInvoices', 'marketplaceId', marketplaceId)
            const localVarPath = `/marketplaces/{marketplace_id}/invoices`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} invoiceId Identificador da fatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundInvoice: async (marketplaceId: string, invoiceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('refundInvoice', 'marketplaceId', marketplaceId)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('refundInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/marketplaces/{marketplace_id}/invoices/{invoice_id}/void`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)))
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} invoiceId Identificador da fatura
         * @param {InvoiceDefinition} [invoiceDefinition] Informações para atualizar uma fatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoice: async (marketplaceId: string, invoiceId: string, invoiceDefinition?: InvoiceDefinition, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('updateInvoice', 'marketplaceId', marketplaceId)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('updateInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/marketplaces/{marketplace_id}/invoices/{invoice_id}`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)))
                .replace(`{${"invoice_id"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceDefinition, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoicesApi - functional programming interface
 * @export
 */
export const InvoicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} invoiceId Identificador da fatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveInvoice(marketplaceId: string, invoiceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveInvoice(marketplaceId, invoiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} invoiceId Identificador da fatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelInvoice(marketplaceId: string, invoiceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelInvoice(marketplaceId, invoiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador marketplace
         * @param {InvoiceDefinition} [invoiceDefinition] Informações para criar uma fatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoice(marketplaceId: string, invoiceDefinition?: InvoiceDefinition, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInvoice(marketplaceId, invoiceDefinition, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} invoiceId Identificador da fatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoice(marketplaceId: string, invoiceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoice(marketplaceId, invoiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoices(marketplaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDefinition & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoices(marketplaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} invoiceId Identificador da fatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundInvoice(marketplaceId: string, invoiceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundInvoice(marketplaceId, invoiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} invoiceId Identificador da fatura
         * @param {InvoiceDefinition} [invoiceDefinition] Informações para atualizar uma fatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInvoice(marketplaceId: string, invoiceId: string, invoiceDefinition?: InvoiceDefinition, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInvoice(marketplaceId, invoiceId, invoiceDefinition, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvoicesApi - factory interface
 * @export
 */
export const InvoicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoicesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} invoiceId Identificador da fatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveInvoice(marketplaceId: string, invoiceId: string, options?: any): AxiosPromise<InvoiceDefinition> {
            return localVarFp.approveInvoice(marketplaceId, invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} invoiceId Identificador da fatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelInvoice(marketplaceId: string, invoiceId: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.cancelInvoice(marketplaceId, invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador marketplace
         * @param {InvoiceDefinition} [invoiceDefinition] Informações para criar uma fatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoice(marketplaceId: string, invoiceDefinition?: InvoiceDefinition, options?: any): AxiosPromise<InvoiceDefinition> {
            return localVarFp.createInvoice(marketplaceId, invoiceDefinition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} invoiceId Identificador da fatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice(marketplaceId: string, invoiceId: string, options?: any): AxiosPromise<InvoiceDefinition> {
            return localVarFp.getInvoice(marketplaceId, invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoices(marketplaceId: string, options?: any): AxiosPromise<ListDefinition & object> {
            return localVarFp.getInvoices(marketplaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} invoiceId Identificador da fatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundInvoice(marketplaceId: string, invoiceId: string, options?: any): AxiosPromise<InvoiceDefinition> {
            return localVarFp.refundInvoice(marketplaceId, invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} invoiceId Identificador da fatura
         * @param {InvoiceDefinition} [invoiceDefinition] Informações para atualizar uma fatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoice(marketplaceId: string, invoiceId: string, invoiceDefinition?: InvoiceDefinition, options?: any): AxiosPromise<InvoiceDefinition> {
            return localVarFp.updateInvoice(marketplaceId, invoiceId, invoiceDefinition, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoicesApi - object-oriented interface
 * @export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
export class InvoicesApi extends BaseAPI {
    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {string} invoiceId Identificador da fatura
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public approveInvoice(marketplaceId: string, invoiceId: string, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).approveInvoice(marketplaceId, invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {string} invoiceId Identificador da fatura
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public cancelInvoice(marketplaceId: string, invoiceId: string, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).cancelInvoice(marketplaceId, invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador marketplace
     * @param {InvoiceDefinition} [invoiceDefinition] Informações para criar uma fatura
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public createInvoice(marketplaceId: string, invoiceDefinition?: InvoiceDefinition, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).createInvoice(marketplaceId, invoiceDefinition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {string} invoiceId Identificador da fatura
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public getInvoice(marketplaceId: string, invoiceId: string, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).getInvoice(marketplaceId, invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public getInvoices(marketplaceId: string, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).getInvoices(marketplaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {string} invoiceId Identificador da fatura
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public refundInvoice(marketplaceId: string, invoiceId: string, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).refundInvoice(marketplaceId, invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {string} invoiceId Identificador da fatura
     * @param {InvoiceDefinition} [invoiceDefinition] Informações para atualizar uma fatura
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public updateInvoice(marketplaceId: string, invoiceId: string, invoiceDefinition?: InvoiceDefinition, options?: AxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).updateInvoice(marketplaceId, invoiceId, invoiceDefinition, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlansApi - axios parameter creator
 * @export
 */
export const PlansApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador marketplace
         * @param {PlanDefinition} [planDefinition] Informações para criar um plano
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlan: async (marketplaceId: string, planDefinition?: PlanDefinition, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('createPlan', 'marketplaceId', marketplaceId)
            const localVarPath = `/marketplaces/{marketplace_id}/plans`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(planDefinition, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} planId Identificador do plano
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlan: async (marketplaceId: string, planId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('deletePlan', 'marketplaceId', marketplaceId)
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('deletePlan', 'planId', planId)
            const localVarPath = `/marketplaces/{marketplace_id}/plans/{plan_id}`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)))
                .replace(`{${"plan_id"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} planId Identificador do plano
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlan: async (marketplaceId: string, planId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('getPlan', 'marketplaceId', marketplaceId)
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('getPlan', 'planId', planId)
            const localVarPath = `/marketplaces/{marketplace_id}/plans/{plan_id}`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)))
                .replace(`{${"plan_id"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlans: async (marketplaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('getPlans', 'marketplaceId', marketplaceId)
            const localVarPath = `/marketplaces/{marketplace_id}/plans`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} planId Identificador do plano
         * @param {PlanDefinition} [planDefinition] Informações para atualizar um plano
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlan: async (marketplaceId: string, planId: string, planDefinition?: PlanDefinition, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('updatePlan', 'marketplaceId', marketplaceId)
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('updatePlan', 'planId', planId)
            const localVarPath = `/marketplaces/{marketplace_id}/plans/{plan_id}`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)))
                .replace(`{${"plan_id"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(planDefinition, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlansApi - functional programming interface
 * @export
 */
export const PlansApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlansApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador marketplace
         * @param {PlanDefinition} [planDefinition] Informações para criar um plano
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlan(marketplaceId: string, planDefinition?: PlanDefinition, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlan(marketplaceId, planDefinition, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} planId Identificador do plano
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlan(marketplaceId: string, planId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlan(marketplaceId, planId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} planId Identificador do plano
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlan(marketplaceId: string, planId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlan(marketplaceId, planId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlans(marketplaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDefinition & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlans(marketplaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} planId Identificador do plano
         * @param {PlanDefinition} [planDefinition] Informações para atualizar um plano
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlan(marketplaceId: string, planId: string, planDefinition?: PlanDefinition, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BuyerDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlan(marketplaceId, planId, planDefinition, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlansApi - factory interface
 * @export
 */
export const PlansApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlansApiFp(configuration)
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador marketplace
         * @param {PlanDefinition} [planDefinition] Informações para criar um plano
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlan(marketplaceId: string, planDefinition?: PlanDefinition, options?: any): AxiosPromise<PlanDefinition> {
            return localVarFp.createPlan(marketplaceId, planDefinition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} planId Identificador do plano
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlan(marketplaceId: string, planId: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.deletePlan(marketplaceId, planId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} planId Identificador do plano
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlan(marketplaceId: string, planId: string, options?: any): AxiosPromise<PlanDefinition> {
            return localVarFp.getPlan(marketplaceId, planId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlans(marketplaceId: string, options?: any): AxiosPromise<ListDefinition & object> {
            return localVarFp.getPlans(marketplaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} planId Identificador do plano
         * @param {PlanDefinition} [planDefinition] Informações para atualizar um plano
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlan(marketplaceId: string, planId: string, planDefinition?: PlanDefinition, options?: any): AxiosPromise<BuyerDefinition> {
            return localVarFp.updatePlan(marketplaceId, planId, planDefinition, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlansApi - object-oriented interface
 * @export
 * @class PlansApi
 * @extends {BaseAPI}
 */
export class PlansApi extends BaseAPI {
    /**
     * 
     * @param {string} marketplaceId Identificador marketplace
     * @param {PlanDefinition} [planDefinition] Informações para criar um plano
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlansApi
     */
    public createPlan(marketplaceId: string, planDefinition?: PlanDefinition, options?: AxiosRequestConfig) {
        return PlansApiFp(this.configuration).createPlan(marketplaceId, planDefinition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {string} planId Identificador do plano
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlansApi
     */
    public deletePlan(marketplaceId: string, planId: string, options?: AxiosRequestConfig) {
        return PlansApiFp(this.configuration).deletePlan(marketplaceId, planId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {string} planId Identificador do plano
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlansApi
     */
    public getPlan(marketplaceId: string, planId: string, options?: AxiosRequestConfig) {
        return PlansApiFp(this.configuration).getPlan(marketplaceId, planId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlansApi
     */
    public getPlans(marketplaceId: string, options?: AxiosRequestConfig) {
        return PlansApiFp(this.configuration).getPlans(marketplaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {string} planId Identificador do plano
     * @param {PlanDefinition} [planDefinition] Informações para atualizar um plano
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlansApi
     */
    public updatePlan(marketplaceId: string, planId: string, planDefinition?: PlanDefinition, options?: AxiosRequestConfig) {
        return PlansApiFp(this.configuration).updatePlan(marketplaceId, planId, planDefinition, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
export const SubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} subscriptionId Identificador da assinatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscription: async (marketplaceId: string, subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('cancelSubscription', 'marketplaceId', marketplaceId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('cancelSubscription', 'subscriptionId', subscriptionId)
            const localVarPath = `/marketplaces/{marketplace_id}/subscriptions/{subscription_id}`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)))
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador marketplace
         * @param {SubscriptionDefinition} [subscriptionDefinition] Informações para criar uma assinatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription: async (marketplaceId: string, subscriptionDefinition?: SubscriptionDefinition, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('createSubscription', 'marketplaceId', marketplaceId)
            const localVarPath = `/marketplaces/{marketplace_id}/subscriptions`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionDefinition, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} subscriptionId Identificador da assinatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription: async (marketplaceId: string, subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('getSubscription', 'marketplaceId', marketplaceId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('getSubscription', 'subscriptionId', subscriptionId)
            const localVarPath = `/marketplaces/{marketplace_id}/subscriptions/{subscription_id}`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)))
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions: async (marketplaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('getSubscriptions', 'marketplaceId', marketplaceId)
            const localVarPath = `/marketplaces/{marketplace_id}/subscriptions`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} subscriptionId Identificador da assinatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reactivateSubscription: async (marketplaceId: string, subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('reactivateSubscription', 'marketplaceId', marketplaceId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('reactivateSubscription', 'subscriptionId', subscriptionId)
            const localVarPath = `/marketplaces/{marketplace_id}/subscriptions/{subscription_id}/reactivate`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)))
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} subscriptionId Identificador da assinatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendSubscription: async (marketplaceId: string, subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('suspendSubscription', 'marketplaceId', marketplaceId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('suspendSubscription', 'subscriptionId', subscriptionId)
            const localVarPath = `/marketplaces/{marketplace_id}/subscriptions/{subscription_id}/suspend`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)))
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} subscriptionId Identificador da assinatura
         * @param {SubscriptionDefinition} [subscriptionDefinition] Informações para atualizar uma assinatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscription: async (marketplaceId: string, subscriptionId: string, subscriptionDefinition?: SubscriptionDefinition, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('updateSubscription', 'marketplaceId', marketplaceId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('updateSubscription', 'subscriptionId', subscriptionId)
            const localVarPath = `/marketplaces/{marketplace_id}/subscriptions/{subscription_id}`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)))
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionDefinition, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} subscriptionId Identificador da assinatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelSubscription(marketplaceId: string, subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelSubscription(marketplaceId, subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador marketplace
         * @param {SubscriptionDefinition} [subscriptionDefinition] Informações para criar uma assinatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscription(marketplaceId: string, subscriptionDefinition?: SubscriptionDefinition, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionDefinition & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscription(marketplaceId, subscriptionDefinition, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} subscriptionId Identificador da assinatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscription(marketplaceId: string, subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionDefinition & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscription(marketplaceId, subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptions(marketplaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDefinition & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptions(marketplaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} subscriptionId Identificador da assinatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reactivateSubscription(marketplaceId: string, subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionDefinition & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reactivateSubscription(marketplaceId, subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} subscriptionId Identificador da assinatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async suspendSubscription(marketplaceId: string, subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionDefinition & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.suspendSubscription(marketplaceId, subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} subscriptionId Identificador da assinatura
         * @param {SubscriptionDefinition} [subscriptionDefinition] Informações para atualizar uma assinatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubscription(marketplaceId: string, subscriptionId: string, subscriptionDefinition?: SubscriptionDefinition, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionDefinition & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscription(marketplaceId, subscriptionId, subscriptionDefinition, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} subscriptionId Identificador da assinatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscription(marketplaceId: string, subscriptionId: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.cancelSubscription(marketplaceId, subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador marketplace
         * @param {SubscriptionDefinition} [subscriptionDefinition] Informações para criar uma assinatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(marketplaceId: string, subscriptionDefinition?: SubscriptionDefinition, options?: any): AxiosPromise<SubscriptionDefinition & object> {
            return localVarFp.createSubscription(marketplaceId, subscriptionDefinition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} subscriptionId Identificador da assinatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription(marketplaceId: string, subscriptionId: string, options?: any): AxiosPromise<SubscriptionDefinition & object> {
            return localVarFp.getSubscription(marketplaceId, subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions(marketplaceId: string, options?: any): AxiosPromise<ListDefinition & object> {
            return localVarFp.getSubscriptions(marketplaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} subscriptionId Identificador da assinatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reactivateSubscription(marketplaceId: string, subscriptionId: string, options?: any): AxiosPromise<SubscriptionDefinition & object> {
            return localVarFp.reactivateSubscription(marketplaceId, subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} subscriptionId Identificador da assinatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendSubscription(marketplaceId: string, subscriptionId: string, options?: any): AxiosPromise<SubscriptionDefinition & object> {
            return localVarFp.suspendSubscription(marketplaceId, subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} subscriptionId Identificador da assinatura
         * @param {SubscriptionDefinition} [subscriptionDefinition] Informações para atualizar uma assinatura
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscription(marketplaceId: string, subscriptionId: string, subscriptionDefinition?: SubscriptionDefinition, options?: any): AxiosPromise<SubscriptionDefinition & object> {
            return localVarFp.updateSubscription(marketplaceId, subscriptionId, subscriptionDefinition, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI {
    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {string} subscriptionId Identificador da assinatura
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public cancelSubscription(marketplaceId: string, subscriptionId: string, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).cancelSubscription(marketplaceId, subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador marketplace
     * @param {SubscriptionDefinition} [subscriptionDefinition] Informações para criar uma assinatura
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public createSubscription(marketplaceId: string, subscriptionDefinition?: SubscriptionDefinition, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).createSubscription(marketplaceId, subscriptionDefinition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {string} subscriptionId Identificador da assinatura
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getSubscription(marketplaceId: string, subscriptionId: string, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).getSubscription(marketplaceId, subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getSubscriptions(marketplaceId: string, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).getSubscriptions(marketplaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {string} subscriptionId Identificador da assinatura
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public reactivateSubscription(marketplaceId: string, subscriptionId: string, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).reactivateSubscription(marketplaceId, subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {string} subscriptionId Identificador da assinatura
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public suspendSubscription(marketplaceId: string, subscriptionId: string, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).suspendSubscription(marketplaceId, subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {string} subscriptionId Identificador da assinatura
     * @param {SubscriptionDefinition} [subscriptionDefinition] Informações para atualizar uma assinatura
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public updateSubscription(marketplaceId: string, subscriptionId: string, subscriptionDefinition?: SubscriptionDefinition, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).updateSubscription(marketplaceId, subscriptionId, subscriptionDefinition, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {TransactionDefinition} [transactionDefinition] Informações para criar uma transação
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction: async (marketplaceId: string, transactionDefinition?: TransactionDefinition, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('createTransaction', 'marketplaceId', marketplaceId)
            const localVarPath = `/marketplaces/{marketplace_id}/transactions`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionDefinition, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {TransactionDefinition} [transactionDefinition] Informações para criar uma transação
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransaction(marketplaceId: string, transactionDefinition?: TransactionDefinition, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransaction(marketplaceId, transactionDefinition, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {TransactionDefinition} [transactionDefinition] Informações para criar uma transação
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction(marketplaceId: string, transactionDefinition?: TransactionDefinition, options?: any): AxiosPromise<TransactionDefinition> {
            return localVarFp.createTransaction(marketplaceId, transactionDefinition, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {TransactionDefinition} [transactionDefinition] Informações para criar uma transação
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createTransaction(marketplaceId: string, transactionDefinition?: TransactionDefinition, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).createTransaction(marketplaceId, transactionDefinition, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador marketplace
         * @param {WebhookDefinition} [webhookDefinition] Informações para criar um webhoook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: async (marketplaceId: string, webhookDefinition?: WebhookDefinition, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('createWebhook', 'marketplaceId', marketplaceId)
            const localVarPath = `/marketplaces/{marketplace_id}/webhooks`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookDefinition, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} webhookId Identificador do webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (marketplaceId: string, webhookId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('deleteWebhook', 'marketplaceId', marketplaceId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteWebhook', 'webhookId', webhookId)
            const localVarPath = `/marketplaces/{marketplace_id}/webhooks/{webhook_id}`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)))
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} webhookId Identificador do webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: async (marketplaceId: string, webhookId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('getWebhook', 'marketplaceId', marketplaceId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('getWebhook', 'webhookId', webhookId)
            const localVarPath = `/marketplaces/{marketplace_id}/webhooks/{webhook_id}`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)))
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks: async (marketplaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('getWebhooks', 'marketplaceId', marketplaceId)
            const localVarPath = `/marketplaces/{marketplace_id}/webhooks`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} webhookId Identificador do webhook
         * @param {WebhookDefinition} [webhookDefinition] Informações para atualizar um webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: async (marketplaceId: string, webhookId: string, webhookDefinition?: WebhookDefinition, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplaceId' is not null or undefined
            assertParamExists('updateWebhook', 'marketplaceId', marketplaceId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateWebhook', 'webhookId', webhookId)
            const localVarPath = `/marketplaces/{marketplace_id}/webhooks/{webhook_id}`
                .replace(`{${"marketplace_id"}}`, encodeURIComponent(String(marketplaceId)))
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookDefinition, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador marketplace
         * @param {WebhookDefinition} [webhookDefinition] Informações para criar um webhoook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebhook(marketplaceId: string, webhookDefinition?: WebhookDefinition, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(marketplaceId, webhookDefinition, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} webhookId Identificador do webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(marketplaceId: string, webhookId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(marketplaceId, webhookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} webhookId Identificador do webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhook(marketplaceId: string, webhookId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhook(marketplaceId, webhookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhooks(marketplaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDefinition & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhooks(marketplaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} webhookId Identificador do webhook
         * @param {WebhookDefinition} [webhookDefinition] Informações para atualizar um webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhook(marketplaceId: string, webhookId: string, webhookDefinition?: WebhookDefinition, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(marketplaceId, webhookId, webhookDefinition, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * 
         * @param {string} marketplaceId Identificador marketplace
         * @param {WebhookDefinition} [webhookDefinition] Informações para criar um webhoook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(marketplaceId: string, webhookDefinition?: WebhookDefinition, options?: any): AxiosPromise<WebhookDefinition> {
            return localVarFp.createWebhook(marketplaceId, webhookDefinition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} webhookId Identificador do webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(marketplaceId: string, webhookId: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.deleteWebhook(marketplaceId, webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} webhookId Identificador do webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(marketplaceId: string, webhookId: string, options?: any): AxiosPromise<WebhookDefinition> {
            return localVarFp.getWebhook(marketplaceId, webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(marketplaceId: string, options?: any): AxiosPromise<ListDefinition & object> {
            return localVarFp.getWebhooks(marketplaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketplaceId Identificador do marketplace
         * @param {string} webhookId Identificador do webhook
         * @param {WebhookDefinition} [webhookDefinition] Informações para atualizar um webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(marketplaceId: string, webhookId: string, webhookDefinition?: WebhookDefinition, options?: any): AxiosPromise<WebhookDefinition> {
            return localVarFp.updateWebhook(marketplaceId, webhookId, webhookDefinition, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * 
     * @param {string} marketplaceId Identificador marketplace
     * @param {WebhookDefinition} [webhookDefinition] Informações para criar um webhoook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public createWebhook(marketplaceId: string, webhookDefinition?: WebhookDefinition, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).createWebhook(marketplaceId, webhookDefinition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {string} webhookId Identificador do webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhook(marketplaceId: string, webhookId: string, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).deleteWebhook(marketplaceId, webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {string} webhookId Identificador do webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhook(marketplaceId: string, webhookId: string, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getWebhook(marketplaceId, webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhooks(marketplaceId: string, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getWebhooks(marketplaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketplaceId Identificador do marketplace
     * @param {string} webhookId Identificador do webhook
     * @param {WebhookDefinition} [webhookDefinition] Informações para atualizar um webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public updateWebhook(marketplaceId: string, webhookId: string, webhookDefinition?: WebhookDefinition, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).updateWebhook(marketplaceId, webhookId, webhookDefinition, options).then((request) => request(this.axios, this.basePath));
    }
}


